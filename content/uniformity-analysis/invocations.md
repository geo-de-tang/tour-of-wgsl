---
title: "Invocations"
---

## Invocations

In WGSL, an invocation refers to a single execution of a shader. Different types of shaders have different invocation patterns, which are important to understand for optimizing performance and ensuring correct behavior.

### Types of Shader Invocations

1. **Vertex Shader Invocations**: Each vertex processed by the vertex shader results in one invocation.
2. **Fragment Shader Invocations**: Each fragment (pixel) processed by the fragment shader results in one invocation.
3. **Compute Shader Invocations**: Each work item in a compute shader results in one invocation.

### Vertex Shader Invocations

In a vertex shader, each vertex in the input vertex buffer triggers an invocation. The vertex shader processes the vertex data and outputs transformed vertex positions and other attributes.

**Example:**
```wgsl
@vertex
fn main(@location(0) position: vec3<f32>) -> @builtin(position) vec4<f32> {
    return vec4<f32>(position, 1.0);
}
```

### Fragment Shader Invocations

In a fragment shader, each fragment generated by rasterizing primitives triggers an invocation. The fragment shader computes the color and other attributes of each pixel.

**Example:**
```wgsl
@fragment
fn main(@location(0) fragCoord: vec4<f32>) -> @location(0) vec4<f32> {
    return vec4<f32>(1.0, 0.0, 0.0, 1.0); // Red color
}
```

### Compute Shader Invocations

In a compute shader, invocations are organized into workgroups. Each work item within a workgroup triggers an invocation. Compute shaders are used for general-purpose computations that are not directly related to graphics rendering.

**Example:**
```wgsl
@compute @workgroup_size(8, 8, 1)
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    // Compute shader code
}
```

### Built-in Variables for Invocations

WGSL provides several built-in variables that give information about the current invocation:

- `@builtin(vertex_index)`: The index of the current vertex.
- `@builtin(instance_index)`: The index of the current instance.
- `@builtin(frag_coord)`: The coordinates of the current fragment.
- `@builtin(global_invocation_id)`: The global ID of the current compute shader invocation.
- `@builtin(local_invocation_id)`: The local ID within the workgroup.
- `@builtin(workgroup_id)`: The ID of the current workgroup.

### Example: Using Built-in Variables

**Vertex Shader Example:**
```wgsl
@vertex
fn main(@builtin(vertex_index) vertexIndex: u32) -> @builtin(position) vec4<f32> {
    // Use vertexIndex to fetch vertex data
    return vec4<f32>(vertexIndex as f32, 0.0, 0.0, 1.0);
}
```

**Fragment Shader Example:**
```wgsl
@fragment
fn main(@builtin(frag_coord) fragCoord: vec4<f32>) -> @location(0) vec4<f32> {
    // Use fragCoord to compute color
    return vec4<f32>(fragCoord.x / 800.0, fragCoord.y / 600.0, 0.0, 1.0);
}
```

**Compute Shader Example:**
```wgsl
@compute @workgroup_size(8, 8, 1)
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    // Use global_id to index into a buffer
}
```

### Summary

Understanding invocations in WGSL is crucial for writing efficient and correct shaders. Each type of shader has its own invocation pattern, and WGSL provides built-in variables to help manage and utilize these invocations effectively.

* Vertex Shader: One invocation per vertex.
* Fragment Shader: One invocation per fragment.
* Compute Shader: One invocation per work item.
* Built-in variables provide context about the current invocation.
